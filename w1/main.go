// каждый раз надо обновлять оболочку" . ~/.bash_profile "и чекать $GOPATH и echo $PATH чтобы там был в конце юзер

// для запсука создать модуль в каталоге: go mod init go-hworks-module
// установить cleanEnv ильи казначчева: в терминале go get -u github.com/ilyakaznacheev/cleanenv
// добавить роутер жулиана шмидта: в терминале прописать go get github.com/julienschmidt/httprouter
// после этого в файле модуля и суммы появятся новые строки

// далее перезапустить VSCODE и после этого должен повяиться автокомплит в том числе
///
///
///
// $GOPATH - переменная среды, используемая в Go для поиска структуры папок.
// Переменная среды $GOPATH пе речисляет места, где Go ищет рабочие пространства Go

// Переменная $GOROOT определяет расположение кода Go, компилятора и инструментов,
// а не нашего исходного кода. Переменная $GOROOT обычно имеет значение
// вида /usr/local/go. Переменная $GOPATH обычно имеет значение вида $HOME/go.

// Операционная система использует переменную среды $PATH для поиска двоичных
// приложений, которые могут выполняться без полного пути. Поэтому чтобы не прописывать полный путь,
// рекомендуется добавить каталог $GOPATH/bin в глобальную переменную $PATH

// Каталог $GOPATH/bin — это место, где Go размещает двоичные файлы, компилируемые go install.
// Каталог $GOPATH/pkg используется Go для хранения предварительно скомпилированных объектных
// файлов для ускорения последующей компиляции программ.

// В каталоге src должны находиться все наши файлы .go или исходный код. Их не следует путать с
// исходным кодом, который используют инструменты Go, и который находится в каталоге $GOROOT.
// При написании приложений, пакетов и библиотек Go мы помещаем эти файлы в каталог $GOPATH/src/path/to/code

// Код Go организован в виде пакетов. Пакет представляет собой все файлы в одном каталоге на диске.
// Один каталог может содержать только определенные файлы из этого же пакета. Пакеты хранятся вместе
// со всеми созданными пользователем исходными файлами Go в каталоге $GOPATH/src.
// Импорт разных пакетов поможет легко понять принципы обработки пакетов. Если наш код находится в
// каталоге $GOPATH/src/blue/red, его имя пакета будет red
//
// Если переменная, структура, поле структуры, константа, функция начинается с заглавной буквы, это значит, что эта
// сущность экспортируемая, то есть она доступна для обращения из других пакетов. Если же она начинается со строчной,
// это значит, что эта сущность при- надлежит только этому пакету.
// Пакет состоит не из файла, а из директории. То есть одна директория — это и есть пакет.
// Импорт в свою очередь распространяется только на файл. Кроме того нельзя оставлять неиспользуе- мые импорты.
// Отдельно хочется отметить, что в go не принято дробить программу на миллион маленьких пакетов, внутри которых лежит
// всего лишь один файл. Правильным подходом считается, когда у вас большие пакеты.
//
// Подробнее: https://www.digitalocean.com/community/tutorials/understanding-the-gopath-ru
// Настройка среды на мак: https://www.digitalocean.com/community/tutorials/how-to-install-go-and-set-up-a-local-programming-environment-on-macos-ru
// Настойка терминала: https://www.youtube.com/watch?v=OwQlxI8z7kI
// https://www.youtube.com/watch?v=Ptk_zcOVPg4&t=16s

/*

ПРИ ПОВТОРЕ РАЗНЕСТИ ПО ОТДЕЛЬНЫМ ФАЙЛОМ ТЕМАТИЧЕСКИМ


package main

import (

	// формативарованный вывод

	"fmt"
	"net/http"
	"unicode/utf8"

	"github.com/julienschmidt/httprouter"

)

	func IndexHandler(w http.ResponseWriter, r *http.Request, params httprouter.Params) {
		w.WriteHeader(200)
		w.Write([]byte("Hello bitches from VScode!"))
	}

	func main() {
		//println("Hello world!")

		//router := httprouter.New()
		//router.GET("/", IndexHandler)

		//log.Fatal(http.ListenAndServe(":8080", router))

		// по умолчанию int инициализируется нулем. Инт платформозависимый тип 32/64. Можно выбрать не платвормозависимые int8/16/32/64

		// получение длины строки

		helloWorld := "Привет Мир"

		byteLen := len(helloWorld)                    // 19 байт (1 символ = 2 байта)
		symbols := utf8.RuneCountInString(helloWorld) // 10 рун

		//fmt.Println(byteLen)
		//fmt.Println(symbols)

		// получение подстроки, в байтах, не символах!
		hello := helloWorld[:12] // 0-11 байты дадут подстроку "Привет" в качестве значения
		H := helloWorld[0]       // byte, вернет значение 208, a не "П"

		//fmt.Println(hello)
		//fmt.Println(H)

		// конвертация в слайс байт и обратно
		byteString := []byte(helloWorld)
		helloWorld = string(byteString)

		//fmt.Println(byteString)
		//fmt.Println(helloWorld)
		_, _, _, _, _, _ = byteLen, symbols, hello, H, byteString, helloWorld

		// iota — это такой автоинкремент для констант,  в обычном контексте содержит в себе значение 0 и увеличивается на 1
		// eдиницу. Например, значения битов в какой-то битовой маске. Автоинкремент тут очень кстати.
		const (
			zero  = iota
			_     // пустая переменная, пропуск iota
			two   // = 2
			three // = 3
		)

		// переменные ни в одноме блоке const, поэтому индекс не увеличился
		const x = iota // x == 0
		const y = iota // y == 0

		// Вы указываете iota на первом месте, а дальше вам не нужно указывать ничего, в данном случае константа
		// 3 объявилась через iota. Если вам нужно пропустить вдруг какую-то константу, вы можете использовать
		// символом подчеркивания, это в go пустая переменная, которая говорит, что, да, здесь должно быть значение,
		// но мы его проигнорируем. При этом iota может выступать не только каким-то простым автоинкрементом, но и
		// участвовать в математических выражениях. Например, в данном случае константа мегабайт
		// определяется тоже через iota.

		const (
			_         = iota             // пропускаем первое значне
			KB uint64 = 1 << (10 * iota) // 1024
			MB                           // 1048576
		)

		// Еще одной особенностью go является то, что нетипизированная константа, которой вы не объявили тип
		// сами, она так и остается внутри нетипизированной. И может в нужное место подставиться уже с нужным типом.
		// За счет этого, например, константы в go могут иметь целочисленные значения, значительно превышающие 64 бита.

		const (
			// нетипизированная константа
			year = 2017
			// типизированная константа
			yearTyped int = 2017
		)

		//package main

		//type UserID int

		//func main() {
		//idx := 1
		//var uid UserID = 42
		// даже если базовый тип одинаковый, разные типы несовместимы
		// cannot use uid (type UserID) as type int64 in assignment
		// myID := idx
		//myID := UserID(idx)
		//println(uid, myID)
		//}
		// Особенностью Go является то, что в нем нет автоматического приведения типов. Никогда! Для того чтобы
		// привести какую-то переменную базового типа к другому типу, который тоже основан на базовом типе,
		// приходится делать конвертацию, в данном случае это типы совместимые, используя объявление типа и
		// скобки, можно привести его к нужному UserID. То есть idx имеет типа int, а myID будет типа UserID.
		//
		// Начать надо с того, что в Go нет адресной арифметики. Вы не можете прибавить какое-то значение к
		// указателю и получить указатель на другую область памяти. В Go указатель — это отдельный тип данных.
		// то это значит? Это значит, что если вы объявляете какую-то переменную как указатель на другую, то
		// внутри этой переменной будет лежать значение адреса на другую переменную. То есть указатель не
		// является полноценной ссылкой, которая указывает ровно туда же, куда и основная переменная.

		//package main

		//import "fmt"

		//func main() {
		a := 2
		b := &a // b объявляем указателем на a
		//fmt.Println(b)  // 0xc0000ac278
		//fmt.Println(*b) // 2
		*b = 3 // изменяем через * значние а, теперь a = 3
		//fmt.Println(a) // 3
		c := &a // новый указатель на переменную a

		// получение указателя на переменнут типа int
		// инициализировано значением по-умолчанию
		d := new(int) // возвращает указатель на значение по умолчанию
		*d = 12
		*c = *d // *c = 12 -> a = 12  , а присовена не ссылка на значение в d, а само значение, поэтому:
		*d = 13 // c и a не изменились
		c = d   // теперь с указывает туда же, куда d
		*c = 14 // с = 14 -> *d = 14, a = 12
		//fmt.Println(d)  // 0xc000126278
		//fmt.Println(*d) // 14

		// Рассмотрим пример. Объявляем переменную a, Создаем переменную b и инициализируем её указателем
		// на a. Теперь мы можем поменять значение в а, используя указатель на а и оператор разыменования *.
		// Указателей на одну и ту же переменную может быть несколько. В строке 9 создаем с - новый указатель
		// на a. Так же возможно создать указатель на какой-то тип данных, что часто используют, например,
		// в структурах.
		// В 13 строке создаем указатель на int, используя ключевое слово int, точнее встроенную
		// функцию int, которая создаст переменную нужного типа, заполнит её значением по умолчанию, (это
		// важно, так как у вас там не будет мусора) и вернёт вам указатель на эту переменную. Посмотрим,
		// как происходит изменение какого-то значения. Сейчас переменная, лежащая за d, проинициализирована
		// нулем. Изменим её значение на 12. Положим в переменную за c значение, которое лежит внутри d. И,
		// таким образом, переменная a, указателем на которую является c, изменится. При этом, если теперь я
		// поменять d, то и c и a уже не меняются, потому что c указывает на a, а не становится сразу же ссылкой на
		// d. Однако, если теперь сделать так, что c — указатель на d, точнее в c теперь находится тот же указатель,
		// который находится внутри d, то при изменении значения c, изменяется значение, которое лежит за c, и
		// значение, которое лежит внутри d, но не значение, которое лежит внутри a.

		// Массив — это какой-то набор из нескольких данных, одного типа. Особенностью массивов в Go является
		// то, что размер массива — это часть типа данных. Что это значит? Это значит, что массив размерностью
		// 2 и массив размерностью 3 — это два совершенно разных типа данных и они между собой несовместимы.
		// Причем размерность массива задается при компиляции, она не может быть изменена динамически.

		// размер массива является частью его типа
		// инициализация значениями по-умолчанию
		var a1 [3]int // [0,0,0]

		// Для определения размера массива можно использовать константы, но не переменные.

		const size = 2        // но не var
		var a2 [2 * size]bool // [false,false,false,false]
		//fmt.Println("a2", a2)

		// Еще можно определить массив при инициализации. То есть я могу указать
		// три точки, это значит, что возьми столько элементов, сколько я тебе скажу, в фигурных скобках. И в
		// фигурных скобках могу сразу же инициализировать этот массив.

		// определение размера при объявлении
		a3 := [...]int{1, 2, 3}
		//fmt.Println("a2", a3)

		// Итак, поскольку мы не всегда знаем, какого размера точно нам нужен массив и мы никак не можем это
		// определить в run time, то массив — это довольно низкоуровневый тип данных, он используется не очень
		// часто. Гораздо чаще используется другой тип, который основывается на массиве и называется он слайс

		// Слайс — это чуть-чуть более сложная структура данных, чем массив, потому что у слайса есть его длина,
		// то есть то количество элементов, которое там уже есть. И capacity, то есть то количество элементов,
		// которое влезет еще в этот слайс без аллоцирования дополнительной памяти.
		// встроенная функция make, которая создает массив нужной размерности и capacit

		var buf0 []int             // len=0, cap=0 - не инициализированный слайс
		buf1 := []int{}            // len=0, cap=0 - инициализированный без элементов
		buf2 := []int{42}          // len=1, cap=1 - иниц. значением 42. Ппод это сразу выделяется массив размерностью 1 элемент
		buf3 := make([]int, 0)     // len=0, cap=0
		buf4 := make([]int, 5)     // len=5, cap=5
		buf5 := make([]int, 5, 10) // len=5, cap=10. Фактически это массив [0, 0, 0, 0, 0] в который в будущем можно добавить
		//  еще 5 других элементов без аллоцироавния дополнительной памяти.
		//  Это очень полезно, если вдруг вы знаете, сколько элементов у вас будет в этом слайсе. Например, вы создаете слайс из нуля элементов, но
		// вы сразу аллоцируете память для десяти элементов. Такой подход очень положительно сказывается на
		// быстродействии программы, потому что если вы доходите до конца слайса и упираетесь в capacity, то
		// тогда ваша программа вынуждена выделять новую область памяти, вдвое большего размера, копировать
		// туда все значения из одной области в другую. А старые значения убирать сборщиком мусора.Очевидно,
		// это не самые легкие операции.
		_, _, _, _, _, _, _, _, _ = a1, a2, a3, buf0, buf1, buf2, buf3, buf4, buf5
		// добавление элементов
		var buf []int            // len=0, cap=0
		buf = append(buf, 9, 10) // len=2, cap=2
		buf = append(buf, 12)    // len=3, cap=4 - капасити x2 от предыдущего размера если не вместилось в текущий.
		// создается и возвращается новый слайс х2 размера, туда копируются элементы из текущего

		// Если у вас есть слайс, вы хотите его домержить в текущий слайс, то для этого есть специальный оператор
		// троеточие.
		// добавление друго слайса
		otherBuf := make([]int, 3)     // [0,0,0]
		buf = append(buf, otherBuf...) // len=6, cap=8

		// Информацию о слайсе можно получить, используя встроенную функцию len, которая говорит вам длину
		// массива, то есть сколько там уже элементов, и функцию cap, capacity, которая говорит, сколько памяти
		// аллоцировано
		// просмотр информации о слайсе
		var bufLen, bufCap int = len(buf), cap(buf)
		//mt.Println(bufLen, bufCap)

		// Еще одной особенностью слайса является то, что можно взять какой-то кусок его, который будет ссылаться ровно на ту же область памяти,
		// на которую ссылается оригинальный слайс.
		buf = []int{1, 2, 3, 4, 5}
		//fmt.Println(buf)

		// получение среза, указывающего на ту же память
		sl1 := buf[1:4] // [2, 3, 4]
		sl2 := buf[:2]  // [1, 2]
		sl3 := buf[2:]  // [3, 4, 5]
		//fmt.Println(sl1, sl2, sl3)
		_, _, _, _, _, _ = bufLen, bufCap, buf, sl1, sl2, sl3
		// В данном примере объявлен слайс из пяти элементов от 1 до 5. Для того чтобы получить элементы,
		// сослаться на какую-то его часть, вы можете в квадратных скобках указать, с какого элемента (включительно) по какой (не включительно)
		// вы хотите сослаться. При этом можно пропустить либо первое значение и сослаться от нуля до в данном случае двойки, либо же пропустить
		// второе значение и сказать: вот отсюда и до конца.
		// Есть очень важная особенность при работе со слайсами, которую нужно понимать. Если вы ссылаетесь на ту же область памяти,
		// (в примере создаем новый слайс такой же размерности  указав «дай мне все»), и изменяете там какое-либо значение, то изменится в обоих слайсах.
		newBuf := buf[:] // [1, 2, 3, 4, 5]
		newBuf[0] = 9
		// buf = [9, 2, 3, 4, 5], т.к. та же память

		// Если же добавить элемент в новый слайс, то тогда произойдет увеличение размерности этого слайса,
		// потому что мы создали слайс, у которого capacity 5, и в нем лежит 5 элементов, и при добавлении 6-
		// ого элемент слайс должен будет расшириться. Это значит, что создастся другая область памяти, и туда
		// скопируются значения. то есть он уже будет ссылаться на другую область памяти. И теперь если поменять
		// какое-то значение, то оно изменится уже в новом слайсе, а в старом не изменится.

		// newBuf теперь указывает на другие данные тк ему возвращается копия слайса с увеличенным капасити
		newBuf = append(newBuf, 6)
		// buf = [9, 2, 3, 4, 5], не изменился
		// newBuf = [9, 2, 3, 4, 5, 6], изменился
		newBuf[0] = 1
		//fmt.Println("buf", buf)
		//fmt.Println("newBuf", newBuf)

		//  Иногда бывает нужно скопировать один слайс в другой: не создать ссылку на ту же область памяти, а именно честно скопировать.
		// Такой способ неправильный
		// копирование одного слайса в другой
		var emptyBuf []int // len=0, cap=0
		// неправильно - скопирует меньшее (по len) из 2-х слайсов
		copied := copy(emptyBuf, buf) // copied = 0
		//fmt.Println(copied, emptyBuf)

		// Когда вы создаете пустой слайс и вызываете функцию копии, она копирует элементы в уже существующий
		// слайс уже в занятые элементы, то есть на место тех элементов, количество которых нам показывает
		// переменная len. В данном случае len для слайса, в который мы копируем, равна 0, и мы на самом деле
		// ничего не скопируем. Для того чтобы скопировать полноценно, нам нужно создать новый слайс, такой
		// же размерности и такой же длины, сразу с данными, и уже скопировать в него.

		// правильно
		newBuf = make([]int, len(buf), len(buf))
		copy(newBuf, buf)
		//fmt.Println(newBuf)
		_, _, _ = copied, emptyBuf, newBuf
		// Тогда поведение будет ожидаемым. Копировать можно не только в переменную, но, например, в срез,
		// слайс, который вы только что получили, который ссылается на какую-то другую область памяти, то есть
		// на другой слайс, на часть другого слайса.

		// можно копировать в часть существующего слайса
		ints := []int{1, 2, 3, 4}
		copy(ints[1:3], []int{5, 6}) // ints = [1, 5, 6, 4]
		//fmt.Println(ints)
		_ = ints
		// Это очень полезный трюк, когда вам нужно сначала записать длину данных, а потом сами данные, при этом размер данных вы еще
		// не знаете (например, при бинарной упаковке). Поэтому вы пишете сначала нулевой размер, потом пишете данные, а потом, используя вот такой трюк,
		// вы пишете длину в нужное место.

		// Еще одним типом данных, про которые мы поговорим — это map. map, он же хеш-таблица, он же ассоциативный массив, он же - сложное
		// слово - «отображение». map позволяет по ключу быстро получить значение. При помощи ключевого слова map, потом в квадратных скобках идет тип
		// ключа и тип данных. При этом вы можете, конечно же, сделать, например, мап мапа мапов. Что может выступать в качестве ключа? В
		// качестве ключа может выступать любая сравниваемая структура данных

		// инициализация при создании 1)
		var user map[string]string = map[string]string{
			"name":     "Vasily",
			"lastName": "Romanov",
		}

		// сразу с нужной ёмкостью 2)
		profile := make(map[string]string, 10)
		// количество элементов
		mapLength := len(user)
		//fmt.Printf("%d %+v\n", mapLength, profile)

		// если ключа нет - вернёт значение по умолчанию для типа
		mName := user["middleName"]
		//fmt.Println("mName:", mName)
		_, _, _ = profile, mapLength, mName
		// Но есть одна особенность: если этого ключа нет в мапе, то вернется значение по умолчанию. Про это
		// обязательно надо помнить! Например, еслиу вас мапа, которая состоит из булов, то значение по умолчанию для була — это false.
		// Если вернется false, то нужно как-то отличать что вам вернулось: значение false, которое действительно лежит по ключу, либо такого
		// ключа вообще нет. Для разрешения этой ситуации можно получить признак существования ключа. Он может быть получен с использованием второй
		// переменной при обращении к мапе

		// проверка на существование ключа
		mName, mNameExist := user["middleName"]
		//fmt.Println("mName:", mName, "mNameExist:", mNameExist)

		// В данном случае получаем признак существования ключа в переменную nNameExist. В ней будет лежать
		// булевая переменная, которая будет говорить, был там ключ, либо не было там ключа. Если же нужно
		// только проверить, есть значение или нет, то можно пропустить первую переменную, используя символ
		// подчеркивания — пустую переменную, говоря,что мы знаем, что там должна быть переменная, но она
		// нам не нужна, и мы её не будем использовать

		// пустая переменная - только проверяем что ключ есть
		_, mNameExist2 := user["middleName"]
		//fmt.Println("mNameExist2", mNameExist2)

		// удаление. В функции delete указываете мапу и ключ
		delete(user, "lastName")
		fmt.Printf("%#v\n", user)

		_, _ = mNameExist, mNameExist2


		// простое условие
		boolVal := true
		if boolVal {
			fmt.Println("boolVal is true")
		}

		// Кроме простых условий, есть условие с блоком инициализации, в котором можно получить результат
		// какой-то функции, либо, например, получить значение существования ключа в map’е, как в примере.
		// После блока инициализации, нужно поставить точку с запятой и написать логическое выражение, значение которого будет проверяться для выполнения
		// условия. В данном случае мы проверяем, что ключ существует или не существует. Также, если не нужна часть значений, получаемых в блоке
		// инициализации, то можно пропустить само значение, используя пустую переменную, то есть символ подчеркивания.

		mapVal := map[string]string{"name": "rvasily"}
		// условие с блоком инициализации
		if keyValue, keyExist := mapVal["name"]; keyExist { // кей по дефолту фалс, так что условие пройдет только если туда вернет тру
			fmt.Println("name =", keyValue)
		}
		// получаем только признак сущестования ключа
		if _, keyExist := mapVal["name"]; keyExist {
			fmt.Println("key ’name’ exist")
		}

		cond := 1
		// множественные if else
		if cond == 1 {
			fmt.Println("cond is 1")
		} else if cond == 2 {
			fmt.Println("cond is 2")
		}



		// Во-первых, в отличие, например, от C, где по
		// умолчанию в switch case у вас происходит проваливание в следующее условие и вам нужно писать везде
		// break, в Go проваливание по умолчанию отсутствует. Вам, наоборот, нужно писать fallthrough, для того
		// чтобы ваша программа провалилась в следующее условие. Также в условиях, то есть в блоке case, может
		// стоять не одно значение, а несколько, перечисленные через запятые. Ну и конечно же, есть блок default,
		// который будет выполнен тогда, когда ни одно из этих условий не применилось.

		// switch по 1 переменной
		strVal := "name"
		switch strVal {
		case "name":
			fallthrough
		case "test", "lastName":
			// some work
		default:
			// some work
		}

		// switch как замена многим ifelse
		var val1, val2 = 2, 2
		switch {
		case val1 > 1 || val2 < 11:
			fmt.Println("first block")
		case val2 > 10:
			fmt.Println("second block")
		}

		// Но иногда бывает нужно, чтобы в операторе
		// 	switch вы завершили какой-то цикл. В этом случае вам нужно указать метку этому циклу.

		// выход из цикла, находясь внутри switch

Loop:

		for key, val := range mapVal {
			println("switch in loop", key, val)
			switch {
			case key == "lastName":
				break // выход из свича
				println("dont pront this")
			case key == "firstName" && val == "Vasily":
				println("switch - break loop here")
				break Loop // выход из цикла с меткой loop
			}
		} // конец for
		// в данном случае она находится на второй строчке, и поставить эту же метку после break.



		// цикл без условия, while(true) OR for(;;;)
		for {
			fmt.Println("loop iteration")
			break
		}

		// цикл c одиночным условием, while(isRun)
		isRun := true
		for isRun {
			fmt.Println("loop iteration with condition")
			isRun = false
		}

		// цикл с условием и блоком инициализации
		for i := 0; i < 2; i++ {
			fmt.Println("loop iteration", i)
			if i == 1 {
				continue // переход к следующей итерации
			}
		}

		// Чаще всего используется автоинкремент индекса, по которому идет цикл. В данном случае мы выполняем
		// всего лишь две итерации. И если у нас i = 1, то мы выполняем переход к следующей итерации цикла. Для
		// этого в Go есть ключевое слово continue.

		// Еще одним примером будет операция по слайсам. Например,
		// объявим слайс и попробуем проитерироваться по нему. Самый простой способ — это использовать одно
		// условие, пока мы не дошли до конца.
		// операции по slice
		sl := []int{1, 2, 3}
		for  idx := 0; idx < len(sl); idx++  {
			fmt.Println("idx:", idx, "value:", sl[idx])
			idx++
		}

		// Четвертым типом цикла, который есть в Go, это цикл с оператором range. Оператор range заменяет всю
		//	рутину, как указать первоначальный индекс, указать условие, указать инкремент для этого индекса, вам
		// достаточно просто проитерироваться, используя оператор range. Оператор range может вам вернуть либо
		// только индекс, элемента из этого слайса,и вы уже сами можете вывести у него значение, например, вот
		// так
		for idx := range sl {
			fmt.Println("range slice by index", sl[idx])
		}

		// Либо же он может вам вернуть сразу значение и индекса и значения, и вам не придется уже обращаться
		// к самому элементу слайса
		for idx, val := range sl {
			fmt.Println("range slice by idx-value", idx, val)
		}
		// При этом происходит создание копии этого значения. Изменяя val элемент слайся не изменится

		//Также вы можете итерироваться в цикле по map.
		// Вы можете итерироваться как только по ключам этой map и сами обращаться к ее значениям.

		// операции по map
		profile := map[int]string{1: "Vasily", 2: "Romanov"}
		for key := range profile {
			fmt.Println("range map by key", key)
		}

		// Также вы можете сразу проитерироваться по ключу и по значению из map,
		// также используя оператор range
		for key, val := range profile {
			fmt.Println("range map by key-val", key, val)
		}
		// либо если нужно только значение
		for _, val := range profile {
			fmt.Println("range map by val", val)
		}

		// Стоит заметить, что что в map порядок ключей не определен. Это значит, что в разных запусках программы ключи в памяти во внутренней
		// структуре map могут располагаться совершенно по-разному. Это
		// обусловлено особенностями реализации. Не ожидайте, что ключи будут в map ровно в том порядке, в
		// котором вы их добавляли.

		// Отдельно стоит отметить, как происходит итерирование по строке. Строка внутри себя представляет слайс
		// байт, но range для строки определен отдельно. Это значит, что, итерируясь по строке по типу string, вы
		// будете итерироваться не по байтам, а уже по отдельным символам. И в том, что вам возвращает range
		// для строки, будет позиция, то есть номер, на котором находится ваш символ, и непосредственно символ,
		// то есть руна, которую представляет собой utf-ный символ
		str := "Привет, Мир!"
		for pos, char := range str {
			fmt.Printf("%#U at pos %d\n", char, pos)
		}

		// ФУНКЦИИ

		// обычное объявление
		func singleIn(in int) int {
			return in
		}

		// много параметров
		func multIn(a, b int, c int) int {
			return a + b + c
		}

		// В Go можно указывать сразу указывать переменную, в которую будет возвращен результат.
		// именованный результат
		func namedReturn() (out int) {
			out = 2
			return
		}
		// При этом вы можете записать туда значение и написать пустой return без имени этой переменной. И она
		// вернет вам то, что вы записали. В данном случае это переменная out. Впрочем, можно написать,например,
		// return 3, даже в таком случае функция будет корректно работать.

		//В Go функции могут возвращать
		// несколько результатов. Чаще всего всего это используется для возврата ошибки в качестве второго параметра

		// несколько результатов
		func multipleReturn(in int) (int, error) {
			if in > 2 {
				return 0, fmt.Errorf("some error happend")
			}
			return in, nil
		}

		// Стоит обратить внимание, что
		// все именованные возвращаемые результаты сразу инициализируются значениями по умолчанию.
		// несколько именованных результатов
		func multipleNamedReturn(ok bool) (rez int, err error) {
			rez = 1
			if ok {
				err = fmt.Errorf("some error happend")
			//return
			// аналогично return rez, err
			return 3, fmt.Errorf("some error happend")
			}
			rez = 2
			return
		}
		// То есть, если в теле функции вы не переприсвоите значение, то будет возвращаться значение по умолчанию. Например,
		// по умолчанию rez = 0, после присвоения rez = 1, функция будет возвращать 1. Если
		// теперь присвоить какое-то значение ошибке на строчке 5, то return будет аналогичен return rez, err.
		// Однако, еще раз обратим внимание,что никто не заставляет использовать именованные результаты. Мы все
		// так же вправе вернуть самостоятельно, например, 3 и ошибку

		// В Go функции могут принимать неограниченное количество параметров, но только одно типа. Такие
		// функции называются вариативными, по английски variative. Для того чтобы так сделать, нужно указать
		// перед типом параметра троеточие
		// не фиксированное количество параметров
		func sum(in ...int) (result int) {
			fmt.Printf("in := %#v \n", in)
			for _, val := range in {
				result += val
			}
			return
		}
		// В этом случае на вход, в данном случае в переменную in, поступит slice интов, по которым вы сможете
		// проитерироваться, используя цикл for range. Обратим внимание на одну тонкость при вызове функции с
		// вариативным числом параметров.
		nums := []int{1, 2, 3, 4}
		fmt.Println(nums, sum(nums...))
		// У нас есть слайс nums, если передать в сумму просто слайс, то компилятор в этом случае будет ругаться,
		// потому что это отдельный тип. А ожидается какое-то количество повторяющихся одиночных параметров.
		// Поэтому необходимо использовать троеточие после имени слайса. Это распаковывает слайс в одиночные
		// аргументы, которые передаются функции. Кстати, функция Println — как раз-таки пример вариативной
		// функции. Она принимает множество параметров и выводит их в строковое представление.


		// А теперь поговорим о функциях, как об объектах первого класса. Слова функция как объект первого
		// класса означают, что вы можете присваивать функцию в какую-то переменную, принимать функцию, как
		// аргумент в другую функцию и возвращать функцию, как результат работы какой-то функции. А также
		// иметь функцию, как поле какой-то структуры. Например, обычная функция, определяется в отдельном
		// блоке.

		// обычная функция
		func doNothing() {
			fmt.Println("i’m regular function")
		}
		// она имеет имя, в данном случае doNothing. А анонимная функция не имеет имени и определяется
		// там, где вы захотите

		// анонимная функция
		func(in string) {
			fmt.Println("anon func out:", in)
		}("nobody")
		// Мы не указываем имя, а сразу после ключевого слова func указываем входныепараметры. И сразу же
		// вызываем эту функцию на строке 5, передавая в качестве параметра строчку nobody. То есть nobody
		// — это параметр анонимной функции, который выведется в Println. Также анонимную функцию можно
		// присвоить какой-то переменную и потом вызвать ее.

		// присванивание анонимной функции в переменную
		printer := func(in string) {
			fmt.Println("printer outs:", in)
		}
		printer("as variable")

		// вы можете определить специальный тип функции. Так же, как и другие типы он определяется при
		// помощи ключевого слова type, имени типа и базовой переменной.

		// определяем тип функции
		type strFuncType func(string)
		// В данном определение функции сигнатура функции тоже может выступать базовым типом. При этом
		// можно указать как входящие параметры, так и возвращаемые значения

		// Теперь давайте рассмотрим следующий вариант, когда мы хотим передавать функцию, как параметр, в другую функцию.
		// Например, определим анонимную функцию worker, которая будет принимать перемен- ную, которая называется callback
		// типа strFuncType, определенного выше. Присвоим анонимную функцию переменной и будем её вызывать.
		// функция принимает коллбек
		worker := func(callback strFuncType) {
				callback("as callback")
		}
		worker(printer)
		//Передадим определенную выше функцию printer, которая будет выводить то, что в нее напечатали. На экран будут выведено
		// as callback, то есть функция printer была вызвана, как callback. Callback-и полезны, если вы необходимо выполнить
		// какую-то функцию по завершении какой-то работы или в зависимости от разных условий выполнить разную логику какой-то
		// другой функции.


		// ЗАМЫКАНИЯ


		// Замыкание — это такая функция, которая обращается к переменным, которые были объявлены вне ее блока, вне ее объявления
		// функиция возвращает замыкание
		prefixer := func(prefix string) strFuncType {
			return func(in string) { // обяъвляем возвращаемую функцию сразу тут
					fmt.Printf("[%s] %s\n", prefix, in) // замыкает префикс который объявлен вне контекста данной функции
			}
		}
		successLogger := prefixer("SUCCESS")
		successLogger("expected behaviour")
		//Когда мы вызываем функцию prefixer, передавая туда строку SUCCESS, то в successLogger записывается функция,
		//принимающая на вход строку и печатающая её с пре- фиксом SUCCESS. После вызова 𝑠𝑢𝑐𝑐𝑒𝑠𝑠𝐿𝑜𝑔𝑔𝑒𝑟(”𝑒𝑥𝑝𝑒𝑐𝑡𝑒𝑑𝑏𝑒h𝑎𝑣𝑖𝑜𝑢𝑟”),
		//как и ожидалось, будет выведено [𝑆𝑈𝐶𝐶𝐸𝑆] 𝑒𝑥𝑝𝑒𝑐𝑡𝑒𝑑 𝑏𝑒h𝑎𝑣𝑖𝑜𝑢𝑟.

		// Мы определяем функцию prefixer, которая принимает строчку prefix и возвращает функцию определен- ного типа.
		// Определяем возвращаемую функцию в строчке return func... У неё есть свой входной параметр in, но она — самое
		// интересное — будет использовать переменную prefix, которая была объявлена не в ее контексте, а в более в контексте
		// более высокого уровня, Это называется замыкание, то есть функция за- мкнулась на что-то. Конечно, поскольку
		// Go — язык со сборщиком мусора, переменная prefix не удалится сразу, как мы вернем значение, а будет существовать
		// до тех пор, пока кто-то использует эту перемен- ную.



		// ОТЛОЖЕННОЕ ВЫПОЛНЕНИЕ ФУНКЦИИ И ПАНИКА

		// Теперь поговорим про такие понятия, как отложенное выполнение, паника и восстановление после па- ники. В Go есть
		// возможность отложенного выполнения функции. Это значит, что какая-то работа будет выполнена после завершения функции.
		// Чаще всего этот подход используется, когда вам нужно посчи- тать, например, время работы функции, либо закрыть
		// какой-то ресурс, например, сетевое соединение либо файловый дескриптор. Причем, если у вас много условий и много
		// returns, в каждом из них руками прописывать это бывает не очень удобно и довольно утомительно. Для этого в Go есть
		// отложенное вы- полнение — вы можете объявить один раз отложенное выполнение на закрытие какого-то ресурса - это
		// делается сразу же после открытия - и забыть о нем. Давайте посмотрим, как это работает.
		package main
		import "fmt"

	    func getSomeVars() string {
	        fmt.Println("getSomeVars execution")
	        return "getSomeVars result"
		}
	    func main() {
	        defer fmt.Println("After work")
	        defer fmt.Println(getSomeVars()) // вызыв в обратном объявлению порядке. А вот аргументы этих функций - в момент объявления. У данной функции есть аргумент - getSomeVars(), поэтому он вычисляется сразу. А вот его резалт уже вернетася после окончания main()
	        fmt.Println("Some userful work")
		}
		// вывод:
		// getSomeVars execution // это аргумент отложенной функции fmt.Println(getSomeVars()), поэтому вычисляется сразу
		// Some userful work // у отложенной fmt.Println("After work")нет аргументов, поэтому далее выполняется не отложенная fmt.Println("Some userful work")
		// getSomeVars result // по порядку обратному объявлению вовзращается отложенный "getSomeVars result"
		// After work // самым последним выполняется After work

		// У нас есть функция main. Вначале мы определяем, что нужно выполнить какую-то функцию отложенно, то есть не сейчас,
		// а в конце. Определяется это через ключевое слово defer, и непосредственно описание вы- зова. При запуске строка
		// Some useful work выведется раньше, чем after work. Если используется несколько отложенных функций, то они
		// выполняются в порядке, обратном их объявлению. В данном случае сначала выполнится функция 𝑓𝑚𝑡.𝑃𝑟𝑖𝑛𝑡𝑙𝑛(𝑔𝑒𝑡𝑆𝑜𝑚𝑒𝑉𝑎𝑟𝑠()),
		// а потом 𝑓𝑚𝑡.𝑃𝑟𝑖𝑛𝑡𝑙𝑛(”𝐴𝑓𝑡𝑒𝑟𝑤𝑜𝑟𝑘”) . Cтоит обратить отдельное внимание на аргументы, которые передаются в отложенные
		// функции. Дело в том, что аргу- менты, передеваемые в отложенные функции, вычисляются на момент их объявления.

		// Потому что сначала выполнилась GetSomeVars, потому что результат её выполнения является аргументом отложенной
		// функции. Потом выполнилась какая-то полезная работа, потом вывелся результат, который вернула нам функция,
		// GetSomeVars, и потом вызвался первый блок defer.

		// Иногда такое поведение бывает не очень удобно, поэтому
		// чаще используется подход, когда мы объявляем анонимную функцию, которая должна быть вызвана в конце.
		package main
		import "fmt"

	    func getSomeVars() string {
	        fmt.Println("getSomeVars execution")
	        return "getSomeVars result"
		}
	    func main() {
	        defer fmt.Println("After work")
	        defer func() {
	            fmt.Println(getSomeVars())
			}()
			fmt.Println("Some userful work")
		}
		// вывод теперь последовательный и привычный:
		// Some userful work // теперь у отложенной func() нет аргументов, поэтому выполняется юзерворк и main() закрывается
		// getSomeVars execution // выполняется отложенная  func(), и функция getSomeVars вызывается только сейчас
		// getSomeVars result // возвращается результат getSomeVars
		// After work // по порядку последней идет результат отложенной fmt.Println("After work")

		// Резюме: отложенные функции выполняются в обратном объявлению пордяке. Если у них есть аргументы - то они вычисляются сразу без отлагательств.

		// ПАНИКА
		// Конструкции с defer очень полезны при восстановлении из паники. Сначала давайте рассмотрим, что такое вообще паника.
		// Представьте, у нас есть какая-то функция, defer test. Она делает какую-то работу и потом паникует.

package main
import "fmt"

func deferTest1() {
	fmt.Println("Some userful work")
	panic("oh shit!") // здесь прервется
	return
}

func main() {
	deferTest2() // тут звершится программа
	return
}

// Some userful work
// panic: oh shit!
//goroutine 1 [running]: и еще куча слов

// Паника это служебная функция, которая останавливает выполнение работы программы, то есть вся про- грамма крашится.
// Как это работает? При выполнении данной функции выполнится какая-то полезная работа, потом вызовется паника и
// напечатается стек трейс. На самсом деле паника штука не очень хоро- шая, и завершать работающий демон в продакшене,
// когда обрабатывается много параллельных запросов, не очень хорошо. Паника — это абсолютно исключительная ситуация.
// И паники надо как-то отлавливать. Отлавливаются они с помощью блока defer.

// Сначала необходимо объявить, собственно, блок, defer, который будет выполнен в любом случае после завершения функции,
// Внутри блока надо воспользоваться функцией recover, которая возвращает ошибку, выброшенную последней паникой.

func deferTest2() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("panic happend:", err)
		}
	}()
	fmt.Println("Some userful work")
	panic("oh shit!") // здесь прервется данная функция и вызовется отложенная функцмя
	return
}

// Some userful work
// panic happend: something bad happend

// Другие функции, которые выполняются позже, могут поймать эту панику, но вообще бросать панику в восстановлении очень
// плохая практика. Так работает паника. Пользуйтесь ею с осторожностью!

*/

//	СТРУКТУРЫ И МЕТОДЫ
//
// Структуры, как и все остальные типы в Go, объявляются через ключевое слово type, потом идёт имя этого типа,
// ключевое слово struct, и в фигурных скобках объявляются поля этой структуры.

/*
package main

import "fmt"

type Person struct {
	ID      int
	Name    string
	Address string
}
type Account1 struct {
	ID      int
	Name    string
	Cleaner func(string) string
	Owner   Person
}

// Как инициализируются структуры? Для того чтобы инициализировать структуры, можно воспользовать- ся либо полным форматом
// объявлений — в фигурных скобках указать нужные поля, при этом какие-то поля можно пропустить,
// и тогда они примут значения по умолчанию.

func main() {
	// 1) полное объявление структуры
	var acc Account1 = Account1{
		ID:   1,
		Name: "rvasily",
	} // остальное будет по умолчанию
	//
	// Либо же мы можем воспользоваться краткой формой объявления, тогда нам не нужно указывать имена
	// всех полей структуры, но при этом нам нужно указать значения абсолютно для всех полей структуры.

	// 2) короткое объявление структуры
	acc.Owner = Person{2, "Romanov Vasily", "Moscow"}

	// Обращение к полям структуры происходит через точку.
	fmt.Println(acc.Name)

	// Иногда бывает так, что мы хотим больше композиции.
	// В Go нет ООП в классическом понимании, однако вся работа с объектами в Go построена на композиции. Например,
	// мы можем встроить одну структуру в другую. Делается это так.

	type Account struct {
		ID      int
		Name    string
		Cleaner func(string) string
		Owner   Person
		Person  // <-- теперь все поля Person также относятся к полям Account2
	}
	// В чем отличие Owner от Person? Дело в том, что Owner — это какое-то свойство структуры, а встроенный,
	// заэмбедженный Person — это уже не свойство структуры, а часть самой структуры. И все поля Person являются частью
	// структуры Account. Например, вы можете обращаться к этим полям непосредственно.
	var acc2 Account = Account{
		ID:   1,
		Name: "rvasily",
	}
	acc2.Owner = Person{2, "Romanov Vasily", "Moscow"}

	fmt.Println(acc2.Address) // <---
	// То есть Address является частью поля структуры Person, но, поскольку мы встроили Person в Account,
	// то мы можем обращаться к полям Person напрямую.

	// Обратим внимание, что при объявлении Person’а встроенной структуры, всё равно нужно объявлять её через префикс.
	var acc3 Account = Account{
		ID:   1,
		Name: "Бобровский",
		Person: Person{
			Name:    "Василий",
			Address: "Москва",
		},
	}
	// Если, как в данном примере, в структуре есть поля с одинаковыми именами у структуры, в которую встраиваем, и у
	// встраиваемой структуры, то никакого конфликта не будет. Оба поля сохранятся. При этом при обращении к этому полю
	// приоритет будет к наиболее верхнему полю структуры. То есть при выполнении fmt.Println(acc.Name) будет выведено
	// поле Account, в котором лежит rvasily, а не поле Person. Если же мы хотим всё-таки обратиться к полю встроенной
	// структуры Person, мы должны явно это указать.
	fmt.Println(acc3.Name)        // Бобровский
	fmt.Println(acc3.Person.Name) // Василий
}
*/
// Методы структур
// Теперь рассмотрим методы. Метод — это какая-то функция, которая может быть привязана к определен- ному типу данных.
// Для начала рассмотрим методы, которые привязываются к структурам.
// Определим тип Person.
/*
package main

import "fmt"

type Person struct {
	Id   int
	Name string
}

//И несколько методов для него.

// не изменит оригинальной структуры, для который вызван. "по значению" - в методе работаем с копией значения поля структуры
func (p Person) UpdateName(name string) {
	p.Name = name // в качестве p у нас копия структуры, на оригинал не влияет
}

// изменяет оригинальную структуру. "по адресу" - в методе работаем непосредственно с полем структуры
func (p *Person) SetName(name string) {
	p.Name = name // в качестве p у нас ссылка на саму структуру
	//(*p).Name = name - в методах структур не обязательно явно прописывать операцию разменовывания
	// указателя при обращении (ведь p это адрес в данном случае), но если мы так зададим метод любого другого типа (структура это исключение),
	// то надо будет писать через звездочку
}

// Метод отличается от обычной функции только тем, что перед определением имени этой функции добав- ляется имя типа,
// для которого определен этот метод, с указанием роли получателя. Роль получателя — это то, в каком виде этот метод
// получит тип, к которому привязан. Это может быть либо передача по значению, то есть вам в метод передается копия
// этого типа, либо по адресу. В первом случае в функции UpdateName любые изменения, вызванные в этом методе,
// оригинальную структуру не затронут. На са- мом деле функция UpdateName смысла не имеет. Если же мы в качестве роли
// указываем адрес на тип, то тогда все изменения, которые были внесены в структуру этим методом сохранятся.

func main() {
	pers := Person{1, "Vasily"} // pers это структура
	fmt.Println(pers.Name)
	pers.SetName("pidr")
	fmt.Println(pers.Name)

	// Поле Name действительно обновляется. Но обратим внимание, что pers у нас не ссылка на структуру, а сама структура.
	// В то время как «получателем» указан адрес структуры. Дело в том, что Go определяет, в каком виде мы хотим получить
	// получателя, либо по значению, либо по адресу, и автоматически выполняет необходимые преобразования.
	// Точно так же можно было вызвать функцию с помощью строчки
	(&pers).SetName("gay")
	fmt.Println(pers.Name)
	// или, например, если бы pers было не структурой, а указателем на структуру, то есть создавалось бы при помощи
	//new(Person) - возвращает указатель
	// или
	//pers := &Person{1, "Vasily"}
	// и вызывалась бы одинаково:
	//pers.SetName("Vasily Romanov")

	// то есть ГО сам все преобразует в нужный вид когда вызывается метод с нужной ролью

	// если встраивать одну структуру в другую, то методы также встраиваются.
	type Account struct {
		Id   int
		Name string
		Person
	}
	// о есть структура account в примере может иметь доступ ко всем методам структур, которые в нее встроены.
	// В данном случае она может иметь доступ к методу SetName. Давайте посмотрим, как это работает.
	// Создадим Account, создадим там Person и вызовем функцию SetName
	var acc Account = Account{
		Id:   1,
		Name: "rvasily",
		Person: Person{
			Id:   2,
			Name: "Vasily Romanov",
		},
	}
	acc.SetName("romanov.vasily")
	fmt.Println(acc.Name) // rvasily
	fmt.Println(acc.Person.Name) // romanov.vasily - метод был для Person
	// После вызова функции изменится значение в Person. Как вы помните, сохраняются оба поля name, кото- рый был и во
	// встроенной структуре, и в структуре верхнего уровня. А что будет если объявить функцию для Аccount?
	func (p *Account) SetName(name string) { // на стринг ругается потому что функция внутри мейна
		p.Name = name
	}
	acc.SetName("Васян")
	fmt.Println(acc.Name) // Васян тк новый метод для Account более общий и перекрыл прошлый сет нейм для персона
	fmt.Println(acc.Person.Name) // romanov.vasily
	// изменится уже поле Name аккаунта, потому что его метод имеет больший приоритет, чем метод встро- енной структуры.
	// Если же теперь требуется вызвать метод непосредственно у встроенной структуры, то обратиться к нему можно,
	// используя полный селектор
	acc.Person.SetName("Василич")
}
*/
// Используя такой подход, можно создавать очень мощные структуры данных. При этом методы могут
// быть не только у структур. Например, можно объявить какой-то тип, например
/*
package main

import "fmt"

type MySlice []int

// у этого типа объявлять методы. Например,с помощью методов можно добавлять значения и получать длину
func (sl *MySlice) Add(val int) {
	*sl = append(*sl, val)
}
func (sl *MySlice) Count() int {
	return len(*sl)
}
func main() {
	sl := MySlice([]int{1, 2})
	sl.Add(5)
	fmt.Println(sl.Count(), sl)
}
*/

// ИНТЕРФЕЙСЫ
// Теперь рассмотрим такую важную часть языка Go, как интерфейсы. Через интерфейсы в Go реализован полиморфизм, то есть
// возможность функции принимать аргументы различных типов. В отличие от таких языков, как C++, Java и PHP, где типизация
// явная, в Go реализована утиная типизация. Что это значит? В C++, когда вы создаете класс, вы явно указываете, что он
// реализует такой интерфейс. «Вот мои документы, вот я наследовался от этого интерфейса, я его реализую. Я — утка.
// Я точно знаю, что я — утка».
// В Go, когда вы создаете структуру с методами, она не знает, какому интерфейсу она
// соответствует, то есть типизация неявная. Там применяется другой подход: Если что-то крякает, как утка, плавает,
// как утка и летает, как утка, то это утка. "Так, у вас есть крылья и клюв, похоже что вы утка". То есть за соблюдение контракта этого интерфейса отвечает не сама структура,
// а метод, в который вы ее передаете. То есть вы передаете в метод, который принимает определенный интерфейс.
// А уже интерфейс описывает, что всем, кто хочет ему удовлетворять необходимо иметь определенные методы.

// то есть за структурой не закрепляется тот факт, что она от кого-то наследуется или соответствует протоколу. Это все узнается по ходу дела
// Вместо этого идет проверка соответствует ли она некоторому интерфейсу, то есть реализует ли описаный в нем набор методов и свойст
// По сути интерфейсы в Swift называют протоколами

// Давайте посмотрим, как это работает в коде.
/*
package main

import "fmt"

// Сначала нужно указать служебное слово type, за- тем имя интерфейса и ключевое слово interface, чтобы указать,
// что этот тип является интерфейсом. В примере объявлен интерфейс Payer, «плательщик», для того чтобы соответствовать
// этому интерфейсу, нужно иметь метод pay, «заплатить», который принимает int и возвращает ошибку. Реализуем структуру
// «кошелек», у которой есть какое-то поле cash, то есть количество денег в этом кошельке, и есть метод «заплатить».

type Payer interface {
	Pay(int) error
}

type Wallet struct {
	Cash int
}

func (w *Wallet) Pay(amount int) error {
	if w.Cash < amount {
		return fmt.Errorf("Не хватает денег в кошельке")
	}
	w.Cash -= amount
	return nil
}

// Обратите внимание: в реализации кошелька нигде нет упоминания того, что он каким-либо образом реа- лизует интерфейс
// «плательщик». И теперь напишем функцию Buy, которая принимает в себя интерфейс «плательщик». Но поскольку у кошелька есть
// метод вида Pay(int) error, то Wallet соответствует интерфейсу Payer и экземпляр кошеля
// может передаваться в Buy как аргумент, хотя он об этом и не догадывается даже (вот в свифте явно
// указывалось за каждой структурой что она реализует определенный протокол, тут же это проверяется по ходу пьесы).
// Buy не знает уже, какую именно структуру в неё передадут, но ей важно, чтобы то, что придет
// в эту функцию, обладало методом Pay.

func Buy(p Payer) {
	err := p.Pay(10)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Спасибо за покупку через %T\n\n", p)
}

// «Спасибо за покупку через main.Wallet»
// При помощи %T в форматируемом выводе можно получить тип переданного аргумента

func main() {
	myWallet := &Wallet{Cash: 100}
	Buy(myWallet)
}
*/
// Это был простой пример, так как в нем была всего одна структура, реализующая интерфейс. Давайте те- перь рассмотрим
// несколько более сложный пример, когда у есть несколько структур, которые реализуют интерфейс.
/*
package main

import (
	"fmt"
	"strconv"
)

// --------------
type Wallet struct {
	Cash int
}

func (w *Wallet) Pay(amount int) error {
	if w.Cash < amount {
		return fmt.Errorf("Не хватает денег в кошельке")
	}
	w.Cash -= amount
	return nil
}

type Card struct {
	Balance    int
	ValidUntil string
	Cardholder string
	CVV        string
	Number     string
}

func (c *Card) Pay(amount int) error {
	if c.Balance < amount {
		return fmt.Errorf("Не хватает денег на карте")
	}
	c.Balance -= amount
	return nil
}

// --------------
type ApplePay struct {
	Money   int
	AppleID string
}

func (a *ApplePay) Pay(amount int) error {
	if a.Money < amount {
		return fmt.Errorf("Не хватает денег на аккаунте")
	}
	a.Money -= amount
	return nil
}

// --------------
type Payer interface {
	Pay(int) error
}

// --------------
func Buy(p Payer) {
	err := p.Pay(10)
	if err != nil {
		fmt.Printf("Ошибка при оплате %T: %v\n\n", p, err)
		return
	}
	fmt.Printf("Спасибо за покупку через %T\n\n", p)

}
*/
/*
// --------------

	func main() {
		myWallet := &Wallet{Cash: 100}
		Buy(myWallet)

		var myMoney Payer // требование соответсвовать интерфейсу можно указать при объявлении переменной
		myMoney = &Card{Balance: 100, Cardholder: "rvasily"}
		Buy(myMoney)

		myMoney = &ApplePay{Money: 9}
		Buy(myMoney)
	}

// Спасибо за покупку через *main.Wallet
// Спасибо за покупку через *main.Card
// Ошибка при оплате *main.ApplePay: Не хватает денег на аккаунте

// Три структуры удовлетворяют интерфейсу Payer потому что имеют метод Pay.
// В main создаем кошелек, и через него что-то покупаем. Теперь создаем не сразу какой-то объект, который дальше будем передавать,
// а переменную типа «плательщик». И теперь в эту переменную можно присва- ивать любые структуры, которые реализуют этот интерфейс.
// То есть проверка на интерфейс может быть не только при передаче в функцию, но и при присвоении в переменную. Соответственно при
// создании структуры можно указывать, что какое-то поле должно иметь определенный интерфейс, соответствовать определенному интерфейсу.
// И, наконец, присваиваем в эту же переменную, которая реализует интерфейс «плательщик», другую реализацию этого плательщика - ApplePay.

// Иногда бывает нужно не просто вызывать какие-то методы интерфейса, но и проверять, какая именно структура, удовлетворяющая интерфейсу
// поступила на вход. Для этих целей у нас есть специальная конструкция type switch. Реализуется она через оператор switch, p и запрос
// типа в скобочках. Перепишем функцию Buy с использованием type switch.

// проверка на то, какой вид структуры удовлетворяющей интерфейсу попал на вход

	func Buy2(p Payer) {
		switch p.(type) {
		case *Wallet:
			fmt.Println("Оплата наличными?")
		case *Card:
			plasticCard, ok := p.(*Card) // чтобы работать с p как с экземпляром Card
			if !ok {
				fmt.Println("Не удалось преобразовать к типу *Card")
			}
			fmt.Println("Вставляйте карту,", plasticCard.Cardholder)
		default:
			fmt.Println("Что-то новое!")
		}
		err := p.Pay(10)
		if err != nil {
			fmt.Printf("Ошибка при оплате %T: %v\n\n", p, err)
			return
		}
		fmt.Printf("Спасибо за покупку через %T\n\n", p)
	}

// вывод:
// Оплата наличными?
// Спасибо за покупку через *main.Wallet
//
// Вставляйте карту, rvasily
// Спасибо за покупку через *main.Card
//
// Что-то новое!
// Ошибка при оплате *main.ApplePay: Не хватает денег на аккаунте

// Смотрите, если интерфейс представлен типом «кошелек», выведем «Оплата наличными». Если интерфейс представлен типом Card, то получим
// доступ к данным этой карточки. Когда в функцию передается интерфейс, нельзя просто так обратиться к полям структуры, которая лежит
// под этим интерфейсом. Если так сделать, будет вызвана паника. Например, Cardholder undefined (type Payer has no field or method Cardholder).
// если мы пытаемся получить доступ к имени владельца. Если преобразование прошло успешно, в plasticCard действительно будет
// лежать тип Card, и теперь можно обращаться к его полям, это уже не интерфейс.
//  тк у нас сейчас на входе требование быть Payer, то это все что известно GO про этот аргумент

	// чтобы обращаться к свойствам самой структуры, нужно преобразовать аргумент к типу этой структуры.
	// таким образом мы делаем проверку на соответствие типу Card, в случае успеха возвращаем новое значения типа Card в plascticCARD
	// тогда можно будет обратиться к полям структуры, находящейся в p.

//
// ПУСТОЙ ИНТЕРФЕЙС

// пустой интерфейс позволяет передать в себя вообще все что угодно
// В этом разделе мы поговорим про пустые интерфейсы. Пустой интерфейс — это интерфейс, который может принять в себя совершенно любую
// переменную, потому что у него нет никаких требований к реализации. Начнём рассматривать пустые интерфейсы с демонстрации их работы.

package main
*/
/*
import (

	"fmt"
	"strconv"

)

	type Wallet struct {
		Cash int
	}

func (w *Wallet) String() string {
	return "Кошелёк в котором " + strconv.Itoa(w.Cash) + " денег"
}
*/
/*
// -----
func main() {
	myWallet := &Wallet{Cash: 100}
	fmt.Printf("Raw payment : %#v\n", myWallet)
	fmt.Printf("Способ оплаты: %s\n", myWallet)
}
*/
// Raw payment : &main.Wallet{Cash:100}
// Способ оплаты: Кошелёк в котором 100 денег

//  Первый формат — это полное Go-шное представление структуры, второй формат — это строка

// Итак, первый вывод вывел прямо имя структуры вместе со всеми полями и значениями, которые там есть. Второй вывод вывел нам какой-то
// текст. Каким образом функция Printf() догадалась, что надо вы- водить?. Явно, что функция стандартной библиотеки не знает ничего про
// тип, который мы только что определили. На самом деле функция Printf() принимает в себя пустой интерфейс. Поэтому мы туда мо- жем
// передавать абсолютно любые параметры, одни за другими, она все из них выведет. Но каким образом получилось, что вывелось то, что надо?
// Дело в том, что если структура, реализует интерфейс Stringer, то тогда функция Pintf() вызовет функцию String, которая уже отформатирует
// вывод так, как мы хотим.

// Пустые интерфейсы — очень полезная вещь, когда нам нужно делать совсем генерические функции, которые работают со всем, чем угодно.
// Как внутри происходит преобразование интерфейсов? Перепишем еще раз функцию для оплаты так, чтоб она принимала не интерфейс-платильщик,
// а пустой интерфейс
/*
func Buy3(in interface{}) { // на вход берем вещи с любым интерфейсом
	var p Payer
	var ok bool
	if p, ok = in.(Payer); !ok {
		fmt.Printf("%T не не является платежным средством\n\n", in)
		return
	}
	err := p.Pay(10)
	if err != nil {
		fmt.Printf("Ошибка при оплате %T: %v\n\n", p, err)
		return
	}
	fmt.Printf("Спасибо за покупку через %T\n\n", p)
}

// В функцию теперь можно передать всё, что угодно, и она должна проверить не на этапе компиляции соответствие интерфейсу,
// а уже в runtime’е. Поэтому нужно попытаться вход преобразовать к платель- щику. Если преобразование не удалось, то выводим, что вход
// платехным средством не является, иначе обрабатываем, как прежде.
func main() {
	myWallet := &Wallet{Cash: 100}
	Buy3(myWallet)
	Buy3([]int{1, 2, 3})
	Buy3(3.14)
}

// Кошелёк пройдет успешно, а вот slice интов и float не пройдут, потому что они не реализуют интерфейс «плательщик».
// Пустые интерфейсы — очень мощный инструмент, и мы будем неоднократно сталкиваться с применением пустого интерфейса.

// КОМПОЗИЦИЯ ИНТЕРФЕЙСОВ

// С интерфейсами можно поступать подобно структурам, ко- гда вы можете вложить одну структуру в другую и иметь доступ к её полям.
// Можете встраивать один интерфейс в другой, тем самым образуя более сложные интерфейсы. Давайте рассмотрим пример.
type Payer2 interface {
	Pay(int) error
}
type Ringer interface {
	Ring(string) error
}
type NFCPhone interface {
	Payer
	Ringer
}

// Объявляем интерфейс Плательщик, который требует метод Pay. И интерфейс Звонилка, который требует метод позвонить. Теперь можно объявить
// интерфейс NFCPhone, то есть телефон, который реализует метод бесконтактной оплаты через NFC технологию. Этот интерфейс образован
// композицией двух других интерфейсов: Плательщик и Звонилка. То есть получается, что на самом деле мой интерфейс выглядит вот так.
type NFCPhone2 interface {
	Pay(int) error
	Ring(string) error
}

// Но каждый раз полностью объявлять совсем новые типы не очень удобно, поэтому композиция интер- фейсов позволяет облегчить жизнь. Не
// обязательно использовать только интерфейсы, один интерфейс можно встроить, а другой, например, объявить. Это также очень мощный
// способ композиции интерфей- сов, и много в стандартной библиотеке реализовано через него.
*/
////////////////////////////////////////////////////////////////////////////

// Теперь мы напишем простую программу для уникализации строк, которые подаются в стандартный ввод. Нам потребуется несколько стандартных
// пакетов: «os» для того, чтобы получить доступ к спинартному вводу, «fnt» для того, чтобы делать форматированный вывод, и
// буферизированный ввод-вывод из пакета io.
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

// В функции для считывания ввода не посимвольно, а сразу всей строкой нам нужен сканер ввода. По- сле того, как мы его создали, будем
// построчно двигаться по вводу в цикле. Когда сканировать будет больше нечего, то scan вернет false, и мы выйдем из цикла. Каждую строку,
// которую мы считали, будем выводить на экран в том случае, если она прежде не встречалась. Для этого можно использовать струк- туру
// 𝑚𝑎𝑝[𝑠𝑡𝑟𝑖𝑛𝑔]𝑏𝑜𝑜𝑙, чтобы запоминать строки, которые мы уже видели, но использовать map может быть не очень выгодно в случае, если у нас
// очень большой массив входных данных — мы можем просто не влезть по памяти. Поэтому сразу напишем программу так, чтобы она была похожа
// на стандартную команду unick, которая принимает на вход отсортированный набор данных. За счет этого мы можем вме- сто всех данных
// хранить только предыдущее значение, но все равно понимать, уникальна ли поданная на вход строка. Если новая строка больше текущей,
// — будем сравнивать просто по байтам, — то она новая, напечатаем её, если совпадает, то мы её уже выводили, если меньше, то это значит,
// что файл не отсортирован, и наша программа в этом случае работать не может, мы просто запаникуем. Итак, вот получившаяся программа.

func uniq(input io.Reader, output io.Writer) error {
	in := bufio.NewScanner(input)
	var prev string
	for in.Scan() {
		txt := in.Text()
		if txt == prev {
			continue
		}
		if txt < prev {
			return fmt.Errorf("file not sorted")
		}
		prev = txt
		fmt.Fprintln(output, txt)
	}
	return nil
}

func main() {
	err := uniq(os.Stdin, os.Stdout)
	if err != nil {
		panic(err.Error())
	}
}

// Теперь давайте приступим к написанию непосредственно тестов. Тесты в go должны лежать в файле, который имеет суффикс test. Например в
// 𝑚𝑎𝑖𝑛 − 𝑡𝑒𝑠𝑡.𝑔𝑜. Все тесты в go начинаются с префикса Test и принимают на вход единственный параметр тестирующего модуля *testing.T.
// Создадим тестовые данные, результат, с которым будем сравнивать работу функции и сам тест.
